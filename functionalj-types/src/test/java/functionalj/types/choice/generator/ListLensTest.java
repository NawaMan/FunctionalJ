package functionalj.types.choice.generator;

import static functionalj.types.TestHelper.assertAsString;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;

import java.util.Objects;
import java.util.stream.Collectors;

import org.junit.Test;

import functionalj.types.Generic;
import functionalj.types.Type;
import functionalj.types.choice.generator.model.Case;
import functionalj.types.choice.generator.model.CaseParam;
import functionalj.types.choice.generator.model.SourceSpec;
import lombok.val;

public class ListLensTest {
    @Test
    public void testListLens_custom() {
        val sourceSpec
                = new SourceSpec("NestedCommand", 
                        new Type("functionalj.types.choice", "NestedListTest", "NestedCommandModel", emptyList()), null, false, "__tagged", emptyList(), 
                        asList(new Case("Rotate", null, asList(new CaseParam("degree", new functionalj.types.Type(null, null, "int", emptyList()), false, null))), 
                               new Case("Move", null, asList(new CaseParam("distance", new functionalj.types.Type(null, null, "int", emptyList()), false, null))), 
                               new Case("Commands", null, asList(new CaseParam("commands", 
                                       new Type("java.util", null, "List", asList(
                                               new Generic("NestedCommand", "NestedCommand", 
                                                       asList(new Type(null, null, "NestedCommand", emptyList()))))), 
                                       false, null)))), emptyList(), 
                        asList("NestedCommand"));
        val generator = new Generator(sourceSpec);
        val generated = generator.lines().stream().filter(Objects::nonNull).collect(Collectors.joining("\n"));
        assertAsString(
                "package functionalj.types.choice;\n"
                + "\n"
                + "import functionalj.lens.core.LensSpec;\n"
                + "import functionalj.lens.lenses.*;\n"
                + "import functionalj.pipeable.Pipeable;\n"
                + "import functionalj.result.Result;\n"
                + "import functionalj.types.Generated;\n"
                + "import java.util.List;\n"
                + "import java.util.function.Consumer;\n"
                + "import java.util.function.Function;\n"
                + "import java.util.function.Supplier;\n"
                + "\n"
                + "@Generated(value = \"FunctionalJ\",date = \"\\E[^\"].+\\Q\", comments = \"functionalj.types.choice.NestedListTest.NestedCommandModel\")\n"
                + "@SuppressWarnings(\"all\")\n"
                + "public abstract class NestedCommand implements IChoice<NestedCommand.NestedCommandFirstSwitch>, Pipeable<NestedCommand> {\n"
                + "    \n"
                + "    public static final Rotate Rotate(int degree) {\n"
                + "        return new Rotate(degree);\n"
                + "    }\n"
                + "    public static final Move Move(int distance) {\n"
                + "        return new Move(distance);\n"
                + "    }\n"
                + "    public static final Commands Commands(List<NestedCommand> commands) {\n"
                + "        return new Commands(commands);\n"
                + "    }\n"
                + "    \n"
                + "    \n"
                + "    public static final NestedCommandLens<NestedCommand> theNestedCommand = new NestedCommandLens<>(\"theNestedCommand\", LensSpec.of(NestedCommand.class));\n"
                + "    public static final NestedCommandLens<NestedCommand> eachNestedCommand = theNestedCommand;\n"
                + "    public static class NestedCommandLens<HOST> extends ObjectLensImpl<HOST, NestedCommand> {\n"
                + "\n"
                + "        public final BooleanAccessPrimitive<NestedCommand> isRotate = NestedCommand::isRotate;\n"
                + "        public final BooleanAccessPrimitive<NestedCommand> isMove = NestedCommand::isMove;\n"
                + "        public final BooleanAccessPrimitive<NestedCommand> isCommands = NestedCommand::isCommands;\n"
                + "        public final ResultLens.Impl<HOST, Rotate, Rotate.RotateLens<HOST>> asRotate = createSubResultLens(\"asRotate\", NestedCommand::asRotate, (functionalj.lens.core.WriteLens<NestedCommand,Result<Rotate>>)(h,r)->r.get(), Rotate.RotateLens::new);\n"
                + "        public final ResultLens.Impl<HOST, Move, Move.MoveLens<HOST>> asMove = createSubResultLens(\"asMove\", NestedCommand::asMove, (functionalj.lens.core.WriteLens<NestedCommand,Result<Move>>)(h,r)->r.get(), Move.MoveLens::new);\n"
                + "        public final ResultLens.Impl<HOST, Commands, Commands.CommandsLens<HOST>> asCommands = createSubResultLens(\"asCommands\", NestedCommand::asCommands, (functionalj.lens.core.WriteLens<NestedCommand,Result<Commands>>)(h,r)->r.get(), Commands.CommandsLens::new);\n"
                + "        public NestedCommandLens(String name, LensSpec<HOST, NestedCommand> spec) {\n"
                + "            super(name, spec);\n"
                + "        }\n"
                + "    }\n"
                + "    \n"
                + "    private NestedCommand() {}\n"
                + "    public NestedCommand __data() throws Exception { return this; }\n"
                + "    public Result<NestedCommand> toResult() { return Result.valueOf(this); }\n"
                + "    \n"
                + "    public static <T extends NestedCommand> T fromMap(java.util.Map<String, ? extends Object> map) {\n"
                + "        String __tagged = (String)map.get(\"__tagged\");\n"
                + "        if (\"Rotate\".equals(__tagged))\n"
                + "            return (T)Rotate.caseFromMap(map);\n"
                + "        if (\"Move\".equals(__tagged))\n"
                + "            return (T)Move.caseFromMap(map);\n"
                + "        if (\"Commands\".equals(__tagged))\n"
                + "            return (T)Commands.caseFromMap(map);\n"
                + "        throw new IllegalArgumentException(\"Tagged value does not represent a valid type: \" + __tagged);\n"
                + "    }\n"
                + "    \n"
                + "    static private functionalj.map.FuncMap<String, java.util.Map<String, functionalj.types.choice.generator.model.CaseParam>> __schema__ = functionalj.map.FuncMap.<String, java.util.Map<String, functionalj.types.choice.generator.model.CaseParam>>newMap()\n"
                + "        .with(\"Rotate\", Rotate.getCaseSchema())\n"
                + "        .with(\"Move\", Move.getCaseSchema())\n"
                + "        .with(\"Commands\", Commands.getCaseSchema())\n"
                + "        .build();\n"
                + "    public static java.util.Map<String, java.util.Map<String, functionalj.types.choice.generator.model.CaseParam>> getChoiceSchema() {\n"
                + "        return __schema__;\n"
                + "    }\n"
                + "    \n"
                + "    public static final class Rotate extends NestedCommand {\n"
                + "        public static final Rotate.RotateLens<Rotate> theRotate = new Rotate.RotateLens<>(\"theRotate\", LensSpec.of(Rotate.class));\n"
                + "        public static final Rotate.RotateLens<Rotate> eachRotate = theRotate;\n"
                + "        private int degree;\n"
                + "        private Rotate(int degree) {\n"
                + "            this.degree = degree;\n"
                + "        }\n"
                + "        public int degree() { return degree; }\n"
                + "        public Rotate withDegree(int degree) { return new Rotate(degree); }\n"
                + "        public static class RotateLens<HOST> extends ObjectLensImpl<HOST, NestedCommand.Rotate> {\n"
                + "            \n"
                + "            public final IntegerLens<HOST> degree = createSubLensInt(\"degree\", NestedCommand.Rotate::degree, NestedCommand.Rotate::withDegree);\n"
                + "            \n"
                + "            public RotateLens(String name, LensSpec<HOST, NestedCommand.Rotate> spec) {\n"
                + "                super(name, spec);\n"
                + "            }\n"
                + "            \n"
                + "        }\n"
                + "        public java.util.Map<String, Object> __toMap() {\n"
                + "            java.util.Map<String, Object> map = new java.util.HashMap<>();\n"
                + "            map.put(\"__tagged\", $utils.toMapValueObject(\"Rotate\"));\n"
                + "            map.put(\"degree\", this.degree);\n"
                + "            return map;\n"
                + "        }\n"
                + "        static private functionalj.map.FuncMap<String, functionalj.types.choice.generator.model.CaseParam> __schema__ = functionalj.map.FuncMap.<String, functionalj.types.choice.generator.model.CaseParam>newMap()\n"
                + "            .with(\"degree\", new functionalj.types.choice.generator.model.CaseParam(\"degree\", new functionalj.types.Type(null, null, \"int\", java.util.Collections.emptyList()), false, null))\n"
                + "            .build();\n"
                + "        public static java.util.Map<String, functionalj.types.choice.generator.model.CaseParam> getCaseSchema() {\n"
                + "            return __schema__;\n"
                + "        }\n"
                + "        public static Rotate caseFromMap(java.util.Map<String, ? extends Object> map) {\n"
                + "            return Rotate(\n"
                + "                    (int)$utils.extractPropertyFromMap(Rotate.class, int.class, map, __schema__, \"degree\")\n"
                + "            );\n"
                + "        }\n"
                + "    }\n"
                + "    public static final class Move extends NestedCommand {\n"
                + "        public static final Move.MoveLens<Move> theMove = new Move.MoveLens<>(\"theMove\", LensSpec.of(Move.class));\n"
                + "        public static final Move.MoveLens<Move> eachMove = theMove;\n"
                + "        private int distance;\n"
                + "        private Move(int distance) {\n"
                + "            this.distance = distance;\n"
                + "        }\n"
                + "        public int distance() { return distance; }\n"
                + "        public Move withDistance(int distance) { return new Move(distance); }\n"
                + "        public static class MoveLens<HOST> extends ObjectLensImpl<HOST, NestedCommand.Move> {\n"
                + "            \n"
                + "            public final IntegerLens<HOST> distance = createSubLensInt(\"distance\", NestedCommand.Move::distance, NestedCommand.Move::withDistance);\n"
                + "            \n"
                + "            public MoveLens(String name, LensSpec<HOST, NestedCommand.Move> spec) {\n"
                + "                super(name, spec);\n"
                + "            }\n"
                + "            \n"
                + "        }\n"
                + "        public java.util.Map<String, Object> __toMap() {\n"
                + "            java.util.Map<String, Object> map = new java.util.HashMap<>();\n"
                + "            map.put(\"__tagged\", $utils.toMapValueObject(\"Move\"));\n"
                + "            map.put(\"distance\", this.distance);\n"
                + "            return map;\n"
                + "        }\n"
                + "        static private functionalj.map.FuncMap<String, functionalj.types.choice.generator.model.CaseParam> __schema__ = functionalj.map.FuncMap.<String, functionalj.types.choice.generator.model.CaseParam>newMap()\n"
                + "            .with(\"distance\", new functionalj.types.choice.generator.model.CaseParam(\"distance\", new functionalj.types.Type(null, null, \"int\", java.util.Collections.emptyList()), false, null))\n"
                + "            .build();\n"
                + "        public static java.util.Map<String, functionalj.types.choice.generator.model.CaseParam> getCaseSchema() {\n"
                + "            return __schema__;\n"
                + "        }\n"
                + "        public static Move caseFromMap(java.util.Map<String, ? extends Object> map) {\n"
                + "            return Move(\n"
                + "                    (int)$utils.extractPropertyFromMap(Move.class, int.class, map, __schema__, \"distance\")\n"
                + "            );\n"
                + "        }\n"
                + "    }\n"
                + "    public static final class Commands extends NestedCommand {\n"
                + "        public static final Commands.CommandsLens<Commands> theCommands = new Commands.CommandsLens<>(\"theCommands\", LensSpec.of(Commands.class));\n"
                + "        public static final Commands.CommandsLens<Commands> eachCommands = theCommands;\n"
                + "        private List<NestedCommand> commands;\n"
                + "        private Commands(List<NestedCommand> commands) {\n"
                + "            this.commands = $utils.notNull(commands);\n"
                + "        }\n"
                + "        public List<NestedCommand> commands() { return commands; }\n"
                + "        public Commands withCommands(List<NestedCommand> commands) { return new Commands(commands); }\n"
                + "        public static class CommandsLens<HOST> extends ObjectLensImpl<HOST, NestedCommand.Commands> {\n"
                + "            \n"
                + "            public final ListLens<HOST, NestedCommand, NestedCommand.NestedCommandLens<HOST>> commands = createSubListLens(NestedCommand.Commands::commands, NestedCommand.Commands::withCommands, NestedCommand.NestedCommandLens::new);\n"
                + "            \n"
                + "            public CommandsLens(String name, LensSpec<HOST, NestedCommand.Commands> spec) {\n"
                + "                super(name, spec);\n"
                + "            }\n"
                + "            \n"
                + "        }\n"
                + "        public java.util.Map<String, Object> __toMap() {\n"
                + "            java.util.Map<String, Object> map = new java.util.HashMap<>();\n"
                + "            map.put(\"__tagged\", $utils.toMapValueObject(\"Commands\"));\n"
                + "            map.put(\"commands\", this.commands);\n"
                + "            return map;\n"
                + "        }\n"
                + "        static private functionalj.map.FuncMap<String, functionalj.types.choice.generator.model.CaseParam> __schema__ = functionalj.map.FuncMap.<String, functionalj.types.choice.generator.model.CaseParam>newMap()\n"
                + "            .with(\"commands\", new functionalj.types.choice.generator.model.CaseParam(\"commands\", new functionalj.types.Type(\"java.util\", null, \"List\", java.util.Arrays.asList(new functionalj.types.Generic(\"NestedCommand\", \"NestedCommand\", java.util.Arrays.asList(new functionalj.types.Type(null, null, \"NestedCommand\", java.util.Collections.emptyList()))))), false, null))\n"
                + "            .build();\n"
                + "        public static java.util.Map<String, functionalj.types.choice.generator.model.CaseParam> getCaseSchema() {\n"
                + "            return __schema__;\n"
                + "        }\n"
                + "        public static Commands caseFromMap(java.util.Map<String, ? extends Object> map) {\n"
                + "            return Commands(\n"
                + "                    (List<NestedCommand>)$utils.extractPropertyFromMap(Commands.class, List.class, map, __schema__, \"commands\")\n"
                + "            );\n"
                + "        }\n"
                + "    }\n"
                + "    \n"
                + "    public java.util.Map<java.lang.String, java.util.Map<java.lang.String, functionalj.types.choice.generator.model.CaseParam>> __getSchema() {\n"
                + "        return getChoiceSchema();\n"
                + "    }\n"
                + "    \n"
                + "    private final NestedCommandFirstSwitch __switch = new NestedCommandFirstSwitch(this);\n"
                + "    @Override public NestedCommandFirstSwitch match() {\n"
                + "         return __switch;\n"
                + "    }\n"
                + "    \n"
                + "    private volatile String toString = null;\n"
                + "    @Override\n"
                + "    public String toString() {\n"
                + "        if (toString != null)\n"
                + "            return toString;\n"
                + "        synchronized(this) {\n"
                + "            if (toString != null)\n"
                + "                return toString;\n"
                + "            toString = $utils.Match(this)\n"
                + "                    .rotate(rotate -> \"Rotate(\" + String.format(\"%1$s\", rotate.degree) + \")\")\n"
                + "                    .move(move -> \"Move(\" + String.format(\"%1$s\", move.distance) + \")\")\n"
                + "                    .commands(commands -> \"Commands(\" + String.format(\"%1$s\", commands.commands) + \")\")\n"
                + "            ;\n"
                + "            return toString;\n"
                + "        }\n"
                + "    }\n"
                + "    \n"
                + "    @Override\n"
                + "    public int hashCode() {\n"
                + "        return toString().hashCode();\n"
                + "    }\n"
                + "    \n"
                + "    @Override\n"
                + "    public boolean equals(Object obj) {\n"
                + "        if (!(obj instanceof NestedCommand))\n"
                + "            return false;\n"
                + "        \n"
                + "        if (this == obj)\n"
                + "            return true;\n"
                + "        \n"
                + "        String objToString  = obj.toString();\n"
                + "        String thisToString = this.toString();\n"
                + "        return thisToString.equals(objToString);\n"
                + "    }\n"
                + "    \n"
                + "    \n"
                + "    public boolean isRotate() { return this instanceof Rotate; }\n"
                + "    public Result<Rotate> asRotate() { return Result.valueOf(this).filter(Rotate.class).map(Rotate.class::cast); }\n"
                + "    public NestedCommand ifRotate(Consumer<Rotate> action) { if (isRotate()) action.accept((Rotate)this); return this; }\n"
                + "    public NestedCommand ifRotate(Runnable action) { if (isRotate()) action.run(); return this; }\n"
                + "    public boolean isMove() { return this instanceof Move; }\n"
                + "    public Result<Move> asMove() { return Result.valueOf(this).filter(Move.class).map(Move.class::cast); }\n"
                + "    public NestedCommand ifMove(Consumer<Move> action) { if (isMove()) action.accept((Move)this); return this; }\n"
                + "    public NestedCommand ifMove(Runnable action) { if (isMove()) action.run(); return this; }\n"
                + "    public boolean isCommands() { return this instanceof Commands; }\n"
                + "    public Result<Commands> asCommands() { return Result.valueOf(this).filter(Commands.class).map(Commands.class::cast); }\n"
                + "    public NestedCommand ifCommands(Consumer<Commands> action) { if (isCommands()) action.accept((Commands)this); return this; }\n"
                + "    public NestedCommand ifCommands(Runnable action) { if (isCommands()) action.run(); return this; }\n"
                + "    \n"
                + "    public static class NestedCommandFirstSwitch {\n"
                + "        private NestedCommand $value;\n"
                + "        private NestedCommandFirstSwitch(NestedCommand theValue) { this.$value = theValue; }\n"
                + "        public <TARGET> NestedCommandFirstSwitchTyped<TARGET> toA(Class<TARGET> clzz) {\n"
                + "            return new NestedCommandFirstSwitchTyped<TARGET>($value);\n"
                + "        }\n"
                + "        \n"
                + "        public <TARGET> NestedCommandSwitchMoveCommands<TARGET> rotate(Function<? super Rotate, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> $action = null;\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    ($value instanceof Rotate)\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Rotate)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public <TARGET> NestedCommandSwitchMoveCommands<TARGET> rotate(Supplier<? extends TARGET> theSupplier) {\n"
                + "            return rotate(d->theSupplier.get());\n"
                + "        }\n"
                + "        public <TARGET> NestedCommandSwitchMoveCommands<TARGET> rotate(TARGET theValue) {\n"
                + "            return rotate(d->theValue);\n"
                + "        }\n"
                + "        \n"
                + "        public <TARGET> NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, Function<? super Rotate, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> $action = null;\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    (($value instanceof Rotate) && check.test((Rotate)$value))\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Rotate)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchRotateMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public <TARGET> NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, Supplier<? extends TARGET> theSupplier) {\n"
                + "            return rotate(check, d->theSupplier.get());\n"
                + "        }\n"
                + "        public <TARGET> NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, TARGET theValue) {\n"
                + "            return rotate(check, d->theValue);\n"
                + "        }\n"
                + "    }\n"
                + "    public static class NestedCommandFirstSwitchTyped<TARGET> {\n"
                + "        private NestedCommand $value;\n"
                + "        private NestedCommandFirstSwitchTyped(NestedCommand theValue) { this.$value = theValue; }\n"
                + "        \n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> rotate(Function<? super Rotate, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> $action = null;\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    ($value instanceof Rotate)\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Rotate)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> rotate(Supplier<? extends TARGET> theSupplier) {\n"
                + "            return rotate(d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> rotate(TARGET theValue) {\n"
                + "            return rotate(d->theValue);\n"
                + "        }\n"
                + "        \n"
                + "        public NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, Function<? super Rotate, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> $action = null;\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    (($value instanceof Rotate) && check.test((Rotate)$value))\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Rotate)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchRotateMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, Supplier<? extends TARGET> theSupplier) {\n"
                + "            return rotate(check, d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, TARGET theValue) {\n"
                + "            return rotate(check, d->theValue);\n"
                + "        }\n"
                + "    }\n"
                + "    public static class NestedCommandSwitchRotateMoveCommands<TARGET> extends ChoiceTypeSwitch<NestedCommand, TARGET> {\n"
                + "        private NestedCommandSwitchRotateMoveCommands(NestedCommand theValue, Function<NestedCommand, ? extends TARGET> theAction) { super(theValue, theAction); }\n"
                + "        \n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> rotate(Function<? super Rotate, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    ($value instanceof Rotate)\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Rotate)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> rotate(Supplier<? extends TARGET> theSupplier) {\n"
                + "            return rotate(d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> rotate(TARGET theValue) {\n"
                + "            return rotate(d->theValue);\n"
                + "        }\n"
                + "        \n"
                + "        public NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, Function<? super Rotate, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    (($value instanceof Rotate) && check.test((Rotate)$value))\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Rotate)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchRotateMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, Supplier<? extends TARGET> theSupplier) {\n"
                + "            return rotate(check, d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchRotateMoveCommands<TARGET> rotate(java.util.function.Predicate<Rotate> check, TARGET theValue) {\n"
                + "            return rotate(check, d->theValue);\n"
                + "        }\n"
                + "    }\n"
                + "    public static class NestedCommandSwitchMoveCommands<TARGET> extends ChoiceTypeSwitch<NestedCommand, TARGET> {\n"
                + "        private NestedCommandSwitchMoveCommands(NestedCommand theValue, Function<NestedCommand, ? extends TARGET> theAction) { super(theValue, theAction); }\n"
                + "        \n"
                + "        public NestedCommandSwitchCommands<TARGET> move(Function<? super Move, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    ($value instanceof Move)\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Move)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchCommands<TARGET> move(Supplier<? extends TARGET> theSupplier) {\n"
                + "            return move(d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchCommands<TARGET> move(TARGET theValue) {\n"
                + "            return move(d->theValue);\n"
                + "        }\n"
                + "        \n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> move(java.util.function.Predicate<Move> check, Function<? super Move, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    (($value instanceof Move) && check.test((Move)$value))\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Move)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchMoveCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> move(java.util.function.Predicate<Move> check, Supplier<? extends TARGET> theSupplier) {\n"
                + "            return move(check, d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchMoveCommands<TARGET> move(java.util.function.Predicate<Move> check, TARGET theValue) {\n"
                + "            return move(check, d->theValue);\n"
                + "        }\n"
                + "    }\n"
                + "    public static class NestedCommandSwitchCommands<TARGET> extends ChoiceTypeSwitch<NestedCommand, TARGET> {\n"
                + "        private NestedCommandSwitchCommands(NestedCommand theValue, Function<NestedCommand, ? extends TARGET> theAction) { super(theValue, theAction); }\n"
                + "        \n"
                + "        public TARGET commands(Function<? super Commands, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    ($value instanceof Commands)\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Commands)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return newAction.apply($value);\n"
                + "        }\n"
                + "        public TARGET commands(Supplier<? extends TARGET> theSupplier) {\n"
                + "            return commands(d->theSupplier.get());\n"
                + "        }\n"
                + "        public TARGET commands(TARGET theValue) {\n"
                + "            return commands(d->theValue);\n"
                + "        }\n"
                + "        \n"
                + "        public NestedCommandSwitchCommands<TARGET> commands(java.util.function.Predicate<Commands> check, Function<? super Commands, ? extends TARGET> theAction) {\n"
                + "            Function<NestedCommand, TARGET> oldAction = (Function<NestedCommand, TARGET>)$action;\n"
                + "            Function<NestedCommand, TARGET> newAction =\n"
                + "                ($action != null)\n"
                + "                ? oldAction : \n"
                + "                    (($value instanceof Commands) && check.test((Commands)$value))\n"
                + "                    ? (Function<NestedCommand, TARGET>)(d -> theAction.apply((Commands)d))\n"
                + "                    : oldAction;\n"
                + "            \n"
                + "            return new NestedCommandSwitchCommands<TARGET>($value, newAction);\n"
                + "        }\n"
                + "        public NestedCommandSwitchCommands<TARGET> commands(java.util.function.Predicate<Commands> check, Supplier<? extends TARGET> theSupplier) {\n"
                + "            return commands(check, d->theSupplier.get());\n"
                + "        }\n"
                + "        public NestedCommandSwitchCommands<TARGET> commands(java.util.function.Predicate<Commands> check, TARGET theValue) {\n"
                + "            return commands(check, d->theValue);\n"
                + "        }\n"
                + "    }\n"
                + "    \n"
                + "    \n"
                + "    \n"
                + "}", generated);
    }
    
}
