package functionalj.kinds.functor;

import static functionalj.functions.StringFunctions.replaceAll;
import static functionalj.functions.StringFunctions.toPath;
import static functionalj.functions.StringFunctions.wrapWith;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.stream.Stream;

import functionalj.functions.Func1;
import functionalj.types.list.FunctionalList;
import functionalj.types.list.FunctionalListFilterAddOn;
import functionalj.types.list.FunctionalListFlatMapAddOn;
import functionalj.types.list.FunctionalListMapAddOn;
import functionalj.types.list.FunctionalListPeekAddOn;
import functionalj.types.result.Result;
import functionalj.types.result.ResultFilterAddOn;
import functionalj.types.result.ResultFlatMapAddOn;
import functionalj.types.result.ResultMapAddOn;
import functionalj.types.result.ResultPeekAddOn;
import lombok.Value;
import lombok.val;
import lombok.experimental.Accessors;

public class DuplicateResultMapToOtherTypeMain {
    
    private static final String dotJAVA = ".java";
    private static final String SLASH = "/";
    private static final String DOT = "\\.";
    private static final String generatorName = DuplicateResultMapToOtherTypeMain.class.getCanonicalName();
    
    @Value
    @Accessors(fluent=true)
    public static class DuplicateConfig {
        private String sourceDir;
        private Class generatedClass;
        private Class replacementClass;
        private Class sourceClass;
        private Class replacedClass;
    }
    
    @SuppressWarnings("rawtypes")
    public static void main(String[] args) {
        duplicateCode(new DuplicateConfig(
                "src/main/java/",
                FunctionalListMapAddOn.class,
                FunctionalList.class,
                ResultMapAddOn.class,
                Result.class
            ),
            null);
        
        duplicateCode(new DuplicateConfig(
                "src/main/java/",
                FunctionalListPeekAddOn.class,
                FunctionalList.class,
                ResultPeekAddOn.class,
                Result.class
            ),
            null);
        
        duplicateCode(new DuplicateConfig(
                "src/main/java/",
                FunctionalListFilterAddOn.class,
                FunctionalList.class,
                ResultFilterAddOn.class,
                Result.class
            ),
            null);
        
        // TODO - Might not make sense for FlatMap.
        duplicateCode(new DuplicateConfig(
                "src/main/java/",
                FunctionalListFlatMapAddOn.class,
                FunctionalList.class,
                ResultFlatMapAddOn.class,
                Result.class
            ),
            list -> list.map(line -> line.replaceAll("Nullable<TARGET>",                            "Stream<? extends TARGET>"))
                        .map(line -> line.replaceAll("import nawaman.nullablej.nullable.Nullable;", "import java.util.stream.Stream;")));
    }
    
    private static void duplicateCode(
            DuplicateConfig                                       config, 
            Func1<FunctionalList<String>, FunctionalList<String>> change) {
        val generatedPckg   = config.generatedClass()  .getPackage().getName();
        val sourcePckg      = config.sourceClass()     .getPackage().getName();
        val generatedName   = config.generatedClass()  .getSimpleName();
        val replacementName = config.replacementClass().getSimpleName();
        val sourceName      = config.sourceClass()     .getSimpleName();
        val replacedName    = config.replacedClass()   .getSimpleName();
        
        sourceCodeLocatedOn(
                config.sourceDir(),
                config.sourceClass()
        )
        .map(readLines())
        .map(list -> list.map(line -> line.replaceAll(sourcePckg,   generatedPckg)))
        .map(list -> list.map(line -> line.replaceAll(sourceName,   generatedName)))
        .map(list -> list.map(line -> line.replaceAll(replacedName, replacementName)))
        .map(list -> (change != null) ? change.apply(list) : list)
        .map(list -> list.append("// Generated by: " + generatorName))
        .printException()
        .ifPresent(lines -> {
            sourceCodeLocatedOn(config.sourceDir(), config.generatedClass())
            .peek   (path -> path.toFile().getParentFile().mkdirs())
            .peek   (path -> path.toFile().delete())
            .peek   (path -> System.out.println("Write to: " + path))
            .forEach(path -> Files.write(path, lines, StandardOpenOption.CREATE_NEW));
        })
        ;
    }
    
    private static Func1<Path, FunctionalList<String>> readLines() {
        return (Path path) -> FunctionalList.ofList(Files.readAllLines(path));
    }
    
    @SuppressWarnings("rawtypes")
    private static Result<Path> sourceCodeLocatedOn(String sourceDir, Class clss) {
        return Result.of(clss)
                .map(Class::getCanonicalName)
                .map(replaceAll(DOT, SLASH))
                .map(wrapWith  (sourceDir, dotJAVA))
                .map(toPath());
    }
    
}
