package functionalj.types.typescript.processor.choice;

import static functionalj.functions.StrFuncs.toCamelCase;
import static functionalj.types.typescript.processor.TypeScriptTypes.toTypeScriptType;
import static java.lang.String.format;
import static java.util.stream.Collectors.joining;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;

import functionalj.types.choice.generator.model.Case;
import functionalj.types.choice.generator.model.CaseParam;

public class TypeScriptChoiceBuilder {
    
    private TypeScriptChoiceSpec choiceSpec;
    private List<String>         structTypes;
    private List<String>         choiceTypes;
    
    /**
     * Create a builder for the given choice.
     * 
     * @param choiceSpec   the choice specification.
     */
    public TypeScriptChoiceBuilder(TypeScriptChoiceSpec choiceSpec) {
        this(choiceSpec, null, null);
    }
    
    /**
     * Create a builder for the given choice.
     * 
     * @param choiceSpec   the choice specification.
     * @param structTypes  the list of struct types.
     * @param choiceTypes  the list of choice types.
     */
    public TypeScriptChoiceBuilder(
            TypeScriptChoiceSpec choiceSpec,
            List<String>         structTypes,
            List<String>         choiceTypes) {
        this.choiceSpec  = choiceSpec;
        this.structTypes = (structTypes == null) ? Collections.emptyList() : structTypes;
        this.choiceTypes = choiceTypes;
    }
    
    String tagName() {
        return "Tag";
    }
    
    /** @return Generate the TypeScript code for the choice. */
    public String toTypeScriptCode() {
        String        topTemplate = "// Generated by FunctionJ.io ( https://functionalj.io ) on %1$s \n";
        LocalDateTime genTime     = LocalDateTime.now();
        String        topLine     = format(topTemplate, genTime);
        
        String choiceEnum
                = choiceEnum();
        
        String typeName = choiceSpec.typeName();
        String choices  = choiceSpec
                .sourceSpec()
                .choices
                .stream ()
                .map    (choice -> choiceType(typeName, choice))
                .collect(joining());
        
        String combined    = combineChoiceType(typeName);
        String encode      = encodeFunction();
        String decode      = decodeFunction();
        String encodeArray = encodeArrayFunction();
        String decodeArray = decodeArrayFunction();
        
        return topLine
                + "\n"
                + choiceEnum
                + "\n"
                + choices 
                + "\n"
                + combined 
                + "\n"
                + encode
                + "\n"
                + decode
                + "\n"
                + encodeArray
                + "\n"
                + decodeArray
                ;
    }
    
    private String choiceEnum() {
        String template
                = "export enum %1$s {\n"
                + "%2$s"
                + "}\n";
        String eachEnumTemplate
                = "    %1$s = \"%1$s\",\n";
        
        String choices  = choiceSpec
                .sourceSpec()
                .choices
                .stream ()
                .map    (choice -> format(eachEnumTemplate, choice.name))
                .collect(joining());
        String tagName = tagName();
        String choiceEnum = format(template, tagName, choices);
        return choiceEnum;
    }
    
    private String choiceType(String typeName, Case choice) {
        String subTypeTemplate
                = "export interface %1$s {\n"
                + "    __tagged: Tag.%1$s;\n"
                + "%2$s"
                + "}\n";
        String parameterTemplate
                = "    %1$s: %2$s;\n";
        
        String choiceName = choice.name;
        String parameters = choice.params.stream().map(param -> {
            String paramName = param.name();
            String paramType = toTypeScriptType(param.type());
            return format(parameterTemplate, paramName, paramType);
        }).collect(joining("\n\n"));
        
        String choiceDef = format(subTypeTemplate, choiceName, parameters);
        return choiceDef;
    }
    
    private String combineChoiceType(String typeName) {
        String template
                = "export type %1$s\n"
                + "            = %2$s;\n"
                + "\n"
                + "export type Type = %1$s;\n";
        
        String choiceNames
                = choiceSpec.sourceSpec()
                .choices.stream()
                .map(choice -> choice.name)
                .collect(joining("\n            | "));
        String combined
                = format(template, typeName, choiceNames);
        
        return combined;
    }
    
    // TODO - If the type is of a list type, this will require different encode/decode function.
    // TODO - For both from and to, we need to check if the type is a list type.
    // TODO - When use stringify, we need to check if there is no custom type.
    
    private String encodeFunction() {
        String template
                = "// Function to encode a %1$s to JSON\n"
                + "export function toJson(%2$s: %1$s): string {\n"
                + "    return JSON.stringify(%2$s);\n"
                + "}\n";
        
        String typeName     = choiceSpec.typeName();
        String variableName = toCamelCase(typeName);
        return format(template, typeName, variableName);
    }
    
    private String decodeFunction() {
        String generalTemplate
                = "// Function to decode a JSON to %1$s\n"
                + "export function fromJson(json: string): %1$s {\n"
                + "    const obj = JSON.parse(json);\n"
                + "    switch (obj.__tagged) {\n"
                + "%2$s"
                + "        default:\n"
                + "            throw new Error(\"Unknown type: Invalid __tagged property: \" + obj.__tagged);\n"
                + "    }\n"
                + "}\n";
        
        String choices = choiceSpec.sourceSpec().choices.stream().map(this::choiceCode).collect(joining());
        String code    = format(generalTemplate, choiceSpec.typeName(), choices);
        return code;
    }
    
    private String encodeArrayFunction() {
        String template
                = "// Function to encode an array of %1$s to JSON\n"
                + "export function toJsonArray(array: %1$s[]): string {\n"
                + "    return JSON.stringify(array.map(toJson));\n"
                + "}\n";
        String typeName  = choiceSpec.typeName();
        return format(template, typeName);
    }
    
    private String decodeArrayFunction() {
        String template
                = "// Function to decode a JSON to an array of %1$s\n"
                + "export function fromJsonArray(json: string): %1$s[] {\n"
                + "    const objArray = JSON.parse(json);\n"
                + "    return objArray.map(fromJson) as %1$s[];\n"
                + "}\n";
        String typeName  = choiceSpec.typeName();
        return format(template, typeName);
    }
    
    private String choiceCode(Case choice) {
        String noParameterTemplate
                = "        case %1$s:\n"
                + "            return obj as %2$s;\n";
        String parameterizeTemplate
                = "        case %1$s:\n"
                + "%2$s"
                + "            return obj as %3$s;\n";
        
        String choiceCode = null;
        String tagName    = tagName();
        String caseTag    = tagName + "." + choice.name;
        if (choice.params.isEmpty()) {
            choiceCode = format(noParameterTemplate, caseTag, choiceSpec.typeName());
        } else {
            String validateParams = choice.params.stream().map(this::caseParamValidation).collect(joining());
            choiceCode = format(parameterizeTemplate, caseTag, validateParams, choiceSpec.typeName());
        }
        return choiceCode;
    }
    
    private String caseParamValidation(CaseParam caseParam) {
        String parameterCheckTemplate
                = "            if (!(typeof obj.%1$s === '%2$s'))\n"
                + "                throw new Error(\"Invalid %1$s (not a %2$s): \" + obj.%1$s);\n";
        String nullableParameterCheckTemplate
                = "            if (!((obj.%1$s === null) || (typeof obj.%1$s === '%2$s')))\n"
                + "                throw new Error(\"Invalid %1$s (not null and not a %2$s): \" + obj.%1$s);\n";
        
        boolean   isNullable       = caseParam.isNullable();
        String    paramName        = caseParam.name();
        String    paramType        = toTypeScriptType(caseParam.type());
        String    validateTemplate = isNullable ? nullableParameterCheckTemplate : parameterCheckTemplate;
        String    validate         = format(validateTemplate, paramName, paramType);
        return validate;
    }
    
}
