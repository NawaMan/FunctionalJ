package functionalj.types.typescript.processor.struct;

import static functionalj.functions.StrFuncs.toCamelCase;
import static functionalj.types.typescript.processor.TypeScriptTypes.toTypeScriptType;
import static java.lang.String.format;
import static java.util.stream.Collectors.joining;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;

public class TypeScriptStructBuilder {
    
    private TypeScriptStructSpec structSpec;
    private List<String>         structTypes;
    private List<String>         choiceTypes;
    
    /**
     * Create a builder for the given struct.
     * 
     * @param structSpec the struct specification.
     */
    public TypeScriptStructBuilder(TypeScriptStructSpec structSpec) {
        this(structSpec, null, null);
    }
    
    /**
     * Create a builder for the given struct.
     * 
     * @param structSpec   the struct specification.
     * @param structTypes  the list of struct types.
     * @param choiceTypes  the list of choice types.
     */
    public TypeScriptStructBuilder(
            TypeScriptStructSpec structSpec,
            List<String>         structTypes,
            List<String>         choiceTypes) {
        this.structSpec  = structSpec;
        this.structTypes = structTypes;
        this.choiceTypes = choiceTypes;
    }
    
    /** @return Generate the TypeScript code for the choice. */
    public String toTypeScriptCode() {
        String topLine     = topLine();
        String imports     = imports();
        String structType  = structType();
        String encode      = encode();
        String decode      = decode();
        String encodeArray = encodeArray();
        String decodeArray = decodeArray();
        return topLine
                + "\n"
                + imports
                + "\n"
                + structType
                + "\n"
                + encode
                + "\n"
                + decode
                + "\n"
                + encodeArray
                + "\n"
                + decodeArray
                ;
    }
    
    private String topLine() {
        String        topTemplate = "// Generated by FunctionJ.io ( https://functionalj.io ) on %1$s \n";
        LocalDateTime genTime     = LocalDateTime.now();
        String        topLine     = format(topTemplate, genTime);
        return topLine;
    }
    
    private String imports() {
        String importTemplate = "import * as %1$s from './%1$s';\n";
        
        String imports = structSpec.sourceSpec().getGetters().stream()
                .map(getter -> {
                    String type = toTypeScriptType(getter.type(), getter.isRequired());
                    if (type.equals("any") || type.equals("any | null")) {
                        if (choiceTypes.contains(getter.type().simpleName())
                         || structTypes.contains(getter.type().simpleName())) {
                            return format(importTemplate, getter.type().simpleName());
                        }
                    }
                    return null;
                })
                .filter(Objects::nonNull)
                .collect(joining());
        return imports;
    }
    
    private String structType() {
        String structTemplate
                = "export type %s = {\n"
                + "%s"
                + "};\n";
        
        String fieldTemplate = "    %s: %s;\n";
        
        String fields = structSpec.sourceSpec().getGetters().stream()
                .map(getter -> {
                    String name = getter.name();
                    String type = toTypeScriptType(getter.type(), getter.isRequired());
                    
                    if (type.equals("any") || type.equals("any | null")) {
                        if (choiceTypes.contains(getter.type().simpleName())
                         || structTypes.contains(getter.type().simpleName())) {
                            String orNull = "";
                            if (type.equals("any | null")) {
                                orNull = " | null";
                            }
                            
                            type = getter.type().simpleName() + ".Type" + orNull;
                        }
                    }
                    return format(fieldTemplate, name, type);
                })
                .collect(joining());
        
        String typeName   = structSpec.typeName();
        String structType = format(structTemplate, typeName, fields);
        return structType;
    }
    
    private String encode() {
        String toJsonTemplate
            = "// Function to encode a Person to JSON\n"
            + "export function toJson(%1$s: %2$s): string {\n"
            + "    return JSON.stringify({\n"
            + "        ...%1$s,\n"
            + "%3$s"
            + "    });\n"
            + "}\n";
        
        String localFieldRequire  = "        %1$s: %2$s.toJson(%3$s.%1$s),\n";
        String localFieldNullable = "        %1$s: %2$s.%1$s ? %3$s.toJson(%2$s.%1$s) : null,\n";
        
        String paramName = toCamelCase(structSpec.typeName());
        String typeName  = structSpec.typeName();
        
        String extraFields = structSpec.sourceSpec().getGetters().stream()
                .map(getter -> {
                    String name = getter.name();
                    String type = toTypeScriptType(getter.type(), getter.isRequired());
                    
                    if (type.equals("any") || type.equals("any | null")) {
                        String getterTypeName = getter.type().simpleName();
                        if (choiceTypes.contains(getterTypeName)
                         || structTypes.contains(getterTypeName)) {
                            if (type.equals("any | null")) {
                                return format(localFieldNullable, name, paramName, getterTypeName);
                            } else {
                                return format(localFieldRequire, name, getterTypeName, paramName);
                            }
                        }
                    }
                    return null;
                })
                .filter(Objects::nonNull)
                .collect(joining());
        
        return format(toJsonTemplate, paramName, typeName, extraFields);
    }
    
    private String decode() {
        String fromJsonTemplate
                = "// Function to decode a JSON to %1$s\n"
                + "export function fromJson(json: string): %1$s {\n"
                + "    const obj = JSON.parse(json);\n"
                + "    return {\n"
                + "        ...obj,\n"
                + "%2$s"
                + "    } as %1$s;\n"
                + "}\n";
        
        String localFieldRequire  = "        %1$s: %2$s.fromJson(obj.%1$s),\n";
        String localFieldNullable = "        %1$s: obj.%1$s ? %2$s.fromJson(obj.%1$s) : null,\n";
        
        String paramName = toCamelCase(structSpec.typeName());
        String typeName  = structSpec.typeName();
        
        String extraFields = structSpec.sourceSpec().getGetters().stream()
                .map(getter -> {
                    String name = getter.name();
                    String type = toTypeScriptType(getter.type(), getter.isRequired());
                    
                    if (type.equals("any") || type.equals("any | null")) {
                        String getterTypeName = getter.type().simpleName();
                        if (choiceTypes.contains(getterTypeName)
                         || structTypes.contains(getterTypeName)) {
                            if (type.equals("any | null")) {
                                return format(localFieldNullable, name, getterTypeName);
                            } else {
                                return format(localFieldRequire, name, getterTypeName, paramName);
                            }
                        }
                    }
                    return null;
                })
                .filter(Objects::nonNull)
                .collect(joining());
        
        return format(fromJsonTemplate, typeName, extraFields);
    }
    
    private String encodeArray() {
        String template
                = "// Function to encode an array of %1$s to JSON\n"
                + "export function toJsonArray(array: %1$s[]): string {\n"
                + "    return JSON.stringify(array.map(toJson));\n"
                + "}\n";
        String typeName  = structSpec.typeName();
        return format(template, typeName);
    }
    
    private String decodeArray() {
        String template
                = "// Function to decode a JSON to an array of %1$s\n"
                + "export function fromJsonArray(json: string): %1$s[] {\n"
                + "    const objArray = JSON.parse(json);\n"
                + "    return objArray.map(fromJson) as %1$s[];\n"
                + "}\n";
        String typeName  = structSpec.typeName();
        return format(template, typeName);
    }
    
}
